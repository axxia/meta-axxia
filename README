meta-axxia
==========

This is the official OpenEmbedded/Yocto BSP layer for Intel’s family of
Axxia Mobile & Enterprise Communication Processors.


Supported MACHINES
==================

Boards Supported by this layer (Please refer to the associate .conf
for more information):

	* axxiaarm - Axxia 5000 ARM Mobile & Enterprise Communication 
                 Processors family (32-bit)

	* axxiaarm64 - Axxia 5000 and 6000 ARM Mobile & Enterprise 
                   Communication Processors family (64-bit)

NOTE: Machines are divided by architecture. By building Linux for
axxiaarm machine (e.g.), you will build binaries for all available ARM
targets.


Reference platforms
===================

Amarillo – Reference board for the Axxia 5500 line of Communication
Processor devices. The 5500 device combines an ARM CPU subsystem with
up to 16 Cortex-A15 Cores along with advanced packet-processing
acceleration engines.

Victoria – Reference board for the Axxia 5600 line of Communication
Processor devices. The 5600 device combines an ARM X9 CPU subsystem
with up to 16 Cortex-A57 Cores along with advanced packet-processing
acceleration engines.

Waco – Reference board for the Axxia 6700 line of Communication
Processor devices. The 6700 device combines an ARM XLF (lionfish) CPU
subsystem with up to 32 Cortex-A53 Cores along with advanced
packet-processing acceleration engines.


Table of Contents
=================

  I. Sources
 II. Dependencies 
III. Build prerequisites
 IV. Building meta-srp
     1. Clone OpenEmbedded/Yocto layers
     2. Prepare and customize the build
     3. Select the image type and start the build
     4. Build and install the SDK
     5. Read-only rootfs with writable overlayfs
  V. Guidelines for submitting patches
 VI. Maintenance
VII. License
  

I. Sources
==========

In most cases, the public repositories can be used (poky,
meta-openembedded, etc.). In the meta-axxia case, however, there are
options. Here's what is available and what each provides.

The Intel github.com repositories have the latest. To access the
private repository, request permission from Intel. Note that the
private repository is used for development and is not supported.

   $ git clone https://github.com/axxia/meta-axxia_private.git meta-axxia

The public Intel repository contains changes that have been submitted
to Yocto, but may not have been accepted yet.

   $ git clone https://github.com/axxia/meta-axxia.git

For changes accepted by the Yocto project, use the following.

   $ git clone git://git.yoctoproject.org/meta-axxia


II. Dependencies
================

For a complete list of dependent layers, please check DEPENDENCIES.


III. Build prerequisites
========================

To begin using the Yocto Project build tools, you must first setup your
work environment and verify that you have the required host packages
installed on the system you will be using for builds. 

Check the YOCTO Reference Manual for the system you are using and verify
you have the minimum required packages installed:
http://www.yoctoproject.org/docs/current/ref-manual/ref-manual.html

Create an empty directory and verify that the partition has at least
50Gb of free space. Next set an environment variable, YOCTO, to the
full path.

   $ cd $HOME
   $ df -h .  # verify output shows adequate space available
   $ mkdir yocto
   $ cd yocto
   $ export YOCTO=$HOME/yocto # should also add to your ~/.bashrc file.


IV. Building meta-axxia
=======================

1. Clone OpenEmbedded/Yocto layers
----------------------------------

1.1 Clone the Yocto Project build tools (Poky) environment.

   $ cd $YOCTO
   $ git clone git://git.yoctoproject.org/poky.git
   $ cd poky
   $ git checkout hardknott

1.2 Clone the Axxia meta layer. This provides meta data for building
   images for the Axxia specific board types.  See 'Sources' above to
   select the right meta-axxia repository, branch, and version.

   $ cd $YOCTO
   $ (the git clone command chosen above)
   $ cd meta-axxia
   $ git checkout hardknott

1.3 The Open Embedded project provides many useful layers and packages
   such as networking. Download the Open Embedded Yocto Project hosted
   repository with the following.

   $ cd $YOCTO
   $ git clone https://github.com/openembedded/meta-openembedded.git
   $ cd meta-openembedded
   $ git checkout hardknott

1.4 Clone Yocto Virtualization Layer which provides packages for
   virtualization such as Linux Container Support (lxc).

   $ cd $YOCTO
   $ git clone git://git.yoctoproject.org/meta-virtualization
   $ cd meta-virtualization
   $ git checkout hardknott


2. Prepare and customize the build
----------------------------------

2.1 Create the build directory. The name is optional and will default
   to 'build', however it helps to choose a name to match the board
   type. For example, we will use axxia.

   $ cd $YOCTO
   $ source meta-axxia/axxia-env
   $ source poky/oe-init-build-env axxia-build

2.2 Check the conf/bblayers.conf file and edit if necessary.

   $ pwd (you should be at $YOCTO/axxia-build)
   $ vi conf/bblayers.conf

BBLAYERS variable should have the following content (references to YOCTO
below shoud be replaced with the actual value you provided prior).

   BBLAYERS ?= " \
            $YOCTO/poky/meta \
            $YOCTO/poky/meta-poky \
            $YOCTO/meta-openembedded/meta-oe \
            $YOCTO/meta-openembedded/meta-networking \
            $YOCTO/meta-openembedded/meta-filesystems \
            $YOCTO/meta-openembedded/meta-python \
            $YOCTO/meta-virtualization \
            $YOCTO/meta-axxia \
            "

2.3 Check the conf/local.conf file and edit if necessary.

   $ vi conf/local.conf

2.3.1 Set distribution configuration to have all Axxia specific features.

    DISTRO = "axxia"

2.3.2 Set Release version. Replace it with the release tag for meta-axxia.

    RELEASE_VERSION = "(meta-axxia-tag)"

2.3.3 Select a specific machine to target the build with:

    NOTE: Machines are divided by architecture. By building Linux for
    axxiaarm machine (e.g.), you will build binaries for all available
    ARM targets.

  - Axxia 5500 ARM Mobile & Enterprise Communication Processors family
    (Amarillo)
  MACHINE = "axxiaarm"

  - Axxia 5600 and 6700 ARM Mobile & Enterprise Communication Processors
    family (Victoria and Waco).
  MACHINE = "axxiaarm64"

2.3.4 Select the root filesystem image compression type (can set
    multiple types):

    NOTE: Default types are set for each machine configuration file
    from conf/machine.

    IMAGE_FSTYPES += "ext2"
    IMAGE_FSTYPES += "tar.gz"
    IMAGE_FSTYPES += "hddimg"

2.3.5 Select the main kernel to use (virtual/kernel provider).
    Meta-axxia is able to build the kernel from 3 sources:

a. Yocto Project Source repositories (git.yoctoproject.org)
   NOTE: Not available until Axxia patches will be submitted upstream.

   for standard
   PREFERRED_PROVIDER_virtual/kernel = "linux-yocto"

   for preempt-rt
   PREFERRED_PROVIDER_virtual/kernel = "linux-yocto-rt"

   will build from Yocto repos:
   5.10: http://git.yoctoproject.org/git/linux-yocto
         v5.10/standard/axxia or v5.10/standard/preempt-rt/axxia branch

b. Public and Private Axxia Github (github.com/axxia)

   for standard
   PREFERRED_PROVIDER_virtual/kernel = "linux-axxia"

   for preempt-rt
   PREFERRED_PROVIDER_virtual/kernel = "linux-axxia-rt"

   will build kernel from Axxia GitHub repositories depending on KREPO_AXXIA
   variable:

   for KREPO_AXXIA = "public" (default):
   5.10: git@github.com:axxia/linux-yocto.git
         v5.10/standard/axxia-dev/base or v5.10/standard/preempt-rt/axxia-dev/base branch

   for KREPO_AXXIA = "private" (require authentication with public key):
   5.10: git@github.com:axxia/linux-yocto_private.git
         v5.10/standard/axxia-dev/base or v5.10/standard/preempt-rt/axxia-dev/base branch

c. Local Kernel repositories (development purpose)

   PREFERRED_PROVIDER_virtual/kernel = "linux-local"

   To use a local kernel repository, you also need to add in local.conf
   or to ajust directly in recipes-kernel/linux/linux-local.bb recipe:

   LOCAL_KERNEL_PATH = "(path-to-local-kernel-repository)"
   LOCAL_KERNEL_BRANCH = "(kernel-branch)"

   NOTE: All changes should be committed in the local kernel.
   NOTE: Full defconfig should be copied in recipes-kernel/linux,
         besides linux-local.bb recipe.

2.3.6 Select the version for the main kernel:

   PREFERRED_VERSION_(preferred-provider)= "5.10%"

NOTE: No preferred version should be set for linux-local provider.

2.3.7 Build multiple versions of the kernel in one build

   By default, meta-axxia builds 4 versions of kernel in one build,
   depending on the generic provider for virtual/kernel: axxia or yocto:
   
   - for any linux-yocto* kernel provider, bitbake will build linux-yocto,
     linux-yocto-rt, linux-yocto-debug and linux-yocto-rt-debug kernels

   - for any linux-axxia* kernel provider, bitbake will build linux-axxia,
     linux-axxia-rt, linux-axxia-debug and linux-axxia-rt-debug kernels

   The kernel which is set as virtual/kernel provider will be installed
   as usual in the deploy directory of the build. Alternative kernels
   with their modules will be installed in deploy directory under separate
   folders having the following template name: kernel-<PN>.
   
   Alternative kernels will be also installed in rootfs on /boot directory
   and the modules for all kernels in /lib/modules/<KENREL_VERSION>.
   Kernels can be swhitch by recreating the Image symlink in /boot or
   copying the choosen fit image from each kernel-<PN> directory.
   Default is the kernel set as preferred provider for virtual/kernel.

   If don't want to build alternative kernels, just reset the following
   variables in local.conf:

   ALTERNATIVE_KERNELS = ""

2.3.8 Customizing the Kernel .config file

NOTE: For linux-axxia (kernel from the Github repositories), defconfigs
      from kernel source tree are used to generate the final .config.

      For linux-yocto (kernel from the Yocto repositories), configuration
      fragments from yocto-kernel-cache repository and from meta layer are
      used to generate the final .config.

      Besides the options specific to the standard and preempt-rt kernel,
      you are able to add extra customizations to the .config by setting the
      following options:

a. Debug options (axxia and yocto):
   - DBG = "no" (DEFAULT)
   - DBG = "yes"
     Will enable options for debug in the Kernel config.

b. Chip specific options (axxia and yocto):
    CHIPSET = "X9" -> add X9 specific kernel options
    CHIPSET = "XLF" -> add XLF specific kernel options

Note: CHIPSET variable is also used for fine tuning (see 8.9).

c. Power management scheme (yocto only):
   - POWER_MANAGEMENT = "low-power" (DEFAULT)
     to keep the core low power when is shut down
   - POWER_MANAGEMENT = "full-power"
     to complete power down the core when is shut down
   - POWER_MANAGEMENT = "full-power-L2"
     to complete power down the core and L2 cache when is shut down

d. Big-endian or little-endian (yocto only):
Set the order in which a sequence of bytes are stored in computer memory.
   - BIG_ENDIAN = "no" (DEFAULT)
     Little-endian is the default settings.
   - BIG_ENDIAN = "yes"
     Kernel will be built with CONFIG_CPU_BIG_ENDIAN enabled.

e. SMP options (yocto only):
   - SMP = "yes" (DEFAULT)
   - SMP = "no"
     Will enable or disable SMP related kernel options.

f. Regression testing (yocto only):
    TESTING = "yes"

2.3.9 Choose proper fine tuning for each CHIPSET As long as specfic
    tunes are defined, user can choose the proper tune using the CHIPSET
    variable. Features and flags for each tune are defined bellow:

- for axxiaarm:
    - CHIPSET = "5500" (DEFAULT) -> default tune: cortexa15-neon
        - TUNE_FEATURES = "arm armv7ve vfp  neon"
        - CFLAGS = "arm-poky-linux-gnueabi-gcc  -march=armv7ve -mfpu=neon
                    -mfloat-abi=softfp 

    - CHIPSET = "X9" -> default tune: cortexa57_32-crypto
        - TUNE_FEATURES = "arm aarch32 neon fp-armv8 callconvention-hard 
                           crypto  cortexa57"
        - CFLAGS = "arm-poky-linux-gnueabi-gcc  -mfpu=crypto-neon-fp-armv8  
                    -mfloat-abi=hard -mcpu=cortex-a57 -mtune=cortex-a57"

    - CHIPSET = "XLF" -> default tune: cortexa53_32-crypto
        - TUNE_FEATURES = "arm aarch32 neon fp-armv8 callconvention-hard 
                           crypto  cortexa53"
        - CFLAGS = "arm-poky-linux-gnueabi-gcc  -mfpu=crypto-neon-fp-armv8 
                    -mfloat-abi=hard -mcpu=cortex-a53 -mtune=cortex-a53"

- for axxiaarm64:
    - CHIPSET = "X9" (DEFAULT) -> default tune: cortexa57_64-crypto
        - TUNE_FEATURES = "aarch64 crypto cortexa57"
        - CFLAGS = "aarch64-poky-linux-gcc  -march=armv8-a+crypto 
                    -mcpu=cortex-a57+crypto -mtune=cortex-a57"

    - CHIPSET = "XLF" -> default tune: cortexa53_64-crypto
        - TUNE_FEATURES = "aarch64 crypto cortexa53"
        - CFLAGS = "aarch64-poky-linux-gcc  -march=armv8-a+crypto 
                    -mcpu=cortex-a53+crypto -mtune=cortex-a53"

NOTE: For ARMv8, AArch64 state, other availabe tunes are for BE with 
          and without crypto (crypto enables olso floating point and advanced 
          SIMD). See conf/machine/include/arm/arch-armv8a.inc
      For ARMv8, AArch32 state, default tunes include hard float, fp-armv8 
          floating-point, thumb and neon extensions. Crypto, thumb and BE are 
          optional.

2.3.10 Building a 32-bit RootFS for ARMv8 based boards:
For ARM architecture, depending on the machine selected on step 7.2, 
specific Kernel and RootFS are built for specific boards:
    - axxiaarm: 32-bit Kernel and Rootfs for 5500 board series which have
                ARMv7 based processors (cortex-a15)
    - axxiaarm64: 64-bit Kernel and Rootfs for 5600 board series which have
                  ARMv8 based processors (cortex-a53 for XLF board or 
                  cortex-a57 for X9 board).
But ARMv8 architecture support both 32-bit and 64-bit instruction sets. 
To build a 32-bit Kernel and RootFS for ARMv8, you will need to set the
following variables in local.conf:

   MACHINE = "axxiaarm"   # for 32-bit 
   CHIPSET = "X9" of CHIPSET = "XLF" (see 7.9)  # for 5600 boards (ARMv8)

If CHIPSET is not set, it will default to 5500 (ARMv7).

NOTE: You can boot the resulting 32-bit RootFS with a 64-bit Kernel 
      resulting from an axxiaarm64 build.

2.3.11 Depending on your processor, set these two options that control
    how much parallelism BitBake should use:

  BB_NUMBER_THREADS = "12"
  PARALLEL_MAKE = "-j 12"
  
2.3.12 Other optional settings for saving disk space and build time:
   
   DL_DIR = "/(some-shared-location)/downloads"
   SSTATE_DIR = "/(some-shared-location)/sstate-cache

2.3.14 Examples.

     See http://www.yoctoproject.org/docs/2.3/mega-manual/mega-manual.html
     for complete documentation on the Yocto build system.

     Here are the local.conf files used for open builds.

MACHINE = "axxiaarm"
CHIPSET = "5500"
SDKIMAGE_FEATURES = "dev-pkgs dbg-pkgs staticdev-pkgs"
IMAGE_FSTYPES += "ext2"
IMAGE_FSTYPES += "tar.gz"
PREFERRED_PROVIDER_virtual/kernel = "linux-axxia-rt"
PREFERRED_VERSION_linux-axxia-rt = "5.10%"
DISTRO = "axxia"
PACKAGE_CLASSES ?= "package_rpm"
EXTRA_IMAGE_FEATURES = "debug-tweaks"
USER_CLASSES ?= "buildstats image-mklibs image-prelink"
PATCHRESOLVE = "noop"
BB_DISKMON_DIRS = "\
    STOPTASKS,${TMPDIR},1G,100K \
    STOPTASKS,${DL_DIR},1G,100K \
    STOPTASKS,${SSTATE_DIR},1G,100K \
    STOPTASKS,/tmp,100M,100K \
    ABORT,${TMPDIR},100M,1K \
    ABORT,${DL_DIR},100M,1K \
    ABORT,${SSTATE_DIR},100M,1K \
    ABORT,/tmp,10M,1K"
PACKAGECONFIG_append_pn-qemu-native = " sdl"
PACKAGECONFIG_append_pn-nativesdk-qemu = " sdl"
CONF_VERSION = "1"


MACHINE = "axxiaarm64"
CHIPSET = "X9"
SDKIMAGE_FEATURES = "dev-pkgs dbg-pkgs staticdev-pkgs"
IMAGE_FSTYPES += "ext2"
IMAGE_FSTYPES += "tar.gz"
PREFERRED_PROVIDER_virtual/kernel = "linux-axxia-rt"
PREFERRED_VERSION_linux-axxia-rt = "5.10%"
DISTRO = "axxia"
PACKAGE_CLASSES ?= "package_rpm"
EXTRA_IMAGE_FEATURES = "debug-tweaks"
USER_CLASSES ?= "buildstats image-mklibs image-prelink"
PATCHRESOLVE = "noop"
BB_DISKMON_DIRS = "\
    STOPTASKS,${TMPDIR},1G,100K \
    STOPTASKS,${DL_DIR},1G,100K \
    STOPTASKS,${SSTATE_DIR},1G,100K \
    STOPTASKS,/tmp,100M,100K \
    ABORT,${TMPDIR},100M,1K \
    ABORT,${DL_DIR},100M,1K \
    ABORT,${SSTATE_DIR},100M,1K \
    ABORT,/tmp,10M,1K"
PACKAGECONFIG_append_pn-qemu-native = " sdl"
PACKAGECONFIG_append_pn-nativesdk-qemu = " sdl"
CONF_VERSION = "1"


3. Select the image type and start the build
--------------------------------------------

   $ cd $YOCTO/axxia-build
   $ bitbake (image type)

Available root filesystem types:
   * axxia-image-min
     A small image used in simulation, flash, or as a ram disk. Should be
     sufficient to use the RTE. 

   * axxia-image-run
     An image used in simulation.

   * axxia-image-dev
     A more complete image including native tool chain and kernel source.

Once complete the images for the target machine will be available in the output
directory 'tmp/deploy/images/$MACHINE'.

3.1. Images generated:

* (image type)-(machine name).ext2 (rootfs in EXT2 format)
* (image type)-(machine name).tar.gz (rootfs in tar+GZIP format)
* modules-(machine name).tgz (modules in tar+GZIP format)
* zImage and zImage-(machine name) (Linux Kernel binary, in u-boot wrapped 
format)
NOTE: For axxiaarm64, only Image files are generated, instead of zImage.
      Use mkimage to convert them to zImage format. 
* (target name).dtb
* FIT images, 3 types:
	* fdt.fit-(target name) (DTB in fit image format)
	* linux.fit-(target name) (Kernel binary in fit image format)
	* multi.fit-(target name) (Kernel binary + DTB in fit image format)


4. Build and install the SDK
----------------------------

Run 'populate_sdk' task for srp-eaglecrest-development image to build
the SDK. 

    $ bitbake axxia-image-dev -c populate_sdk

It will install a self extracting script in tmp/deploy/sdk. Simply run
the poky*.sh script. To set up the environment to use the tools, source
environment-setup* in the install directory.

After the installation completes, do the following:

4.1 Optional Linux Module Tools Update

If external Linux modules need to be buildable after installing the
SDK, the Linux kernel sources need to be updated as follows, using the
external-modules-setup.sh script which is deployed with the SDK.

source (install directory)/environment-setup*
./(install directory)/external-modules-setup.sh

The SDK should contain all you need to run the above. In case the Linux
build fails because of missing packages on the host, be sure you have
the following installed: libncurses5-dev flex bison libssl-dev dkms
libelf-dev (for Ubuntu).

4.2 libnl Links

At present, no links get created in (sysroot)/usr/lib for the expected
names of the netlink libraries.  DPDK, for example, expects
libnl-3.so, but the SDK has libnl-3.so.200 (which is a link to the
actual library, libnl-3.so.200.23.0 etc.).  Fix this as follows.

cd $SYSROOT/usr/lib
ln -s libnl-3.so.200 libnl-3.so
ln -s libnl-genl-3.so.200 libnl-genl-3.so
ln -s libnl-nf-3.so.200 libnl-nf-3.so
ln -s libnl-route-3.so.200 libnl-route-3.so

4.3 Some Updates for LTTng

cd $SYSROOT/usr/lib
sed -i "s|/usr/lib|$SYSROOT/usr/lib|" liblttng-ust.la


5. Read-only rootfs with writable overlayfs
-------------------------------------------

Having a read-only root file system is useful for many scenarios:
* Separate user specific changes from system configuration
* Allow factory reset, by deleting the user specific changes
* Have a fallback image in case the user specific changes made the root
  file system no longer bootable
* Share root file system to boot multiple boards via NFS

Because some data on the root file system changes on first boot or
while the system is running, just mounting the complete root file
system as read-only breaks many applications.

Instead of having a read-only root files system and symlinking/bind
mounting files and directories that could potentially change while the
system is running to a writable partition, mounting a writable overlay
root file system, that uses a read-only file system as its base and
writes changed data to another writable partition.

Here no investigation of writable files are needed and factory reset
can be done by just deleting all files or formatting the writable
volume. In case when upperdir of the overlay is mounted as tmpfs, all
the changes will be reset on reboot.

In order to boot the rootfs read-only with writable overlayfs, set the
custom init-readonly-overlay script as init script for boot with the
following Kernel command line parameter:

    init=/init-readonly-overlay

This will mount the rootfs read-only in /media/rfs/ro, a tmpfs
mountpoint will be created in /media/rfs/rw and an overlayfs will be
mounted on root / directory using the readonly rootfs as lowerdir and
the tmpfs one as upperdir. All the user specific changes will be stored
in tmpfs, so will be volative.

For persistent user changes, a new read-write device/partition need to
be present and set with the following Kernel command line parameter:

    rootrw=/dev/sda1
    
The lower filesystem can be any filesystem supported by Linux and does
not need to be writable. But, since the upper filesystem will normally
be writable, it must support the creation of trusted.* extended
attributes, and must provide valid d_type in readdir responses, so NFS
is not suitable.

Other Kernel command line parameters:
root= specifies the read-only root file system device. If this is not 
      specified, the current rootfs is used.

rootfstype= if support for the read-only file system is not build into
            the kernel, you can specify the required module name here.
            It will also be used in the mount command.

rootoptions= specifies the mount options of the read-only file system. 
             Defaults to noatime,nodiratime.

rootinit= if the init parameter was set to init-readonly-overlay script,
          rootinit can be used to overwrite the default (/sbin/init).
          E.g. rootinit=/bin/sh

rootrw= specifies the read-write file system device. If this is not
        specified, tmpfs is used.

rootrwfstype= if support for the read-write file system is not build
              into the kernel, you can specify the required module name
              here. It will also be used in the mount command.

rootrwoptions= specifies the mount options of the read-write file
               system. Defaults to rw,noatime.

rootrwreset= set to yes if you want to delete all the files in the
             read-write file system prior to building the overlay root
             files system.

More details on how to setup a writable root file system overlay on
top of a read-only root file system can be found in
meta-readonly-rootfs-overlay layer [1], and details about overlays can
be found in the Kernel official documentation [2].

1. https://github.com/cmhe/meta-readonly-rootfs-overlay
2. https://www.kernel.org/doc/Documentation/filesystems/overlayfs.txt


V. Guidelines for submitting patches
======================================

Please submit any patches against meta-axxia BSPs to the meta-axxia
mailing list (meta-axxia@yoctoproject.org) and cc: the maintainers.

Mailing list:
	https://lists.yoctoproject.org/listinfo/meta-axxia

When creating patches, please use something like:
	git format-patch -s --subject-prefix='meta-axxia][PATCH' origin

When sending patches, please use something like:
	git send-email --to meta-axxia@yoctoproject.org --cc (maintainers)
		      (generated patch)


VI. Maintenance
===============

Maintainers: John Jacques (john.jacques@intel.com)
             Daniel Dragomir (daniel.dragomir@windriver.com)

Please see the meta-axxia/MAINTAINERS file for more details.


VII. License
==========

All metadata is MIT licensed unless otherwise stated. Souce code included
in tree for individual recipes is under the LICENSE stated in each recipe
(.bb file) unless otherwise stated.
